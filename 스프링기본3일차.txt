스프링 기본 3일차

_______________________________________________________________________________________

클라이언트의 새로운 할인정책을 적용 할 예정.
->이렇게 되면 OCP와 DIP를 지키지 못하게 됨.

위 두가지 객체지향적 설계의 원칙을 지키기 위해
다양한 시도를 하면서 코드를 수정해 나갈건데,
이를 통해서 왜 스프링 DI 컨테이너가 등장하게 된건지 깨닫게 될 예정.
이후 이 순수한 자바코드를 spring으로 전환하는 과정도 경험 할 예정.





새로운 할인정책(=기능의 확장)

정액 할인금액(vip만 1000원) 에서 정률 할인금액(퍼센트 할인 정책)으로 변경 요청.

인터페이스를 만들어서 구현체로 만들었으니, 이런 기능의 확장에 대해 코드의 수정없이
새로운 구현체를 만듬으로써 교체가 가능해야함.

RateDiscountPolict(정률 할인정책)
-> 퍼센트라 나눗셈 연산을 해야해서, return결과가 제대로 됐는지 알고싶음
->test 케이스 작성해야되는데,

*꿀팁 intellij에선 ctrl+shift+t하면 테스트케이스를 바로 작성할수 있음.
DisplayName엔 내가 test로 검사하고자 하는 것들을 string으로 넣을 수 있음.

intellij의 테스트케이스가 야무진게,
실패시 Assertions.assertThat에서 기대했던 값과 결과값이 나옴.


**
강사님께서,
Assertions.assertThat()메서드에서
alt+enter하면 Assertions를 static으로 import해서 assertThat()만 쓰면 돼서 편리하다고 하셨는데,

static import란?
클래스에 대한 인스턴스(객체) 생성 없이 바로 메소드를 쓸 수 있음.
그래서 Assertions.을 안쓰고 바로 assertThat()을 쓸 수 있는 것.
**


_______________________________________________________________________________________


새로운 할인정책의 "적용"과 문제점.


OrderServiceImpl에서 주문 서비스를 처리하기때문에,
할인률정책 바뀐걸 여기에서 바꿔줘야 하는데

Fix->Discount로 클래스를 바꿔주면 할인정책이 새롭게 적용된다.

근데, 이러면 클라이언트에 해당하는 클래스인 OrderServiceImpl의 코드를 바꿔줘야함.

역할과 구현을 분리했고,
다형성을 구현했고, 이로 인한 인터페이스와 구현체 분리도 했다.

"OCP DIP를 준수한 것처럼 보이지만, 사실은 그렇지 않다."

클라이언트 클래스에 해당하는 OrderServiceImpl에서
private final DiscountPolicy discountPolicy=new RateDiscountPolicy();
이 코드에 대해 인터페이스인 DiscountPolicy를 의존(=이 클래스를 알고있다)하지만
이것의 구현체인 RateDiscountPolicy도 의존함(알고있음)
->우리는 "DiscountPolicy(추상)만 의존하게끔" 설계해야, DIP를 지킬수 있음.
->추상에도 의존하고, 구현에도 의존을 함.->DIP위반.(의존관계 역전 법칙)


DIP를 위반하면, OCP도 위반하게 됨.
구현을 의존하고 있었기때문에, 정책이 바뀌어서 구현체를 새로 만들어 갈아 끼우려면
구현코드를 바꿔줘야함.->수정에 닫혀있지 않음.


역할과 구현은 분리했는데, 구현의 교체를 할때마다 라이센스를 "갱신"(=코드의 변경)이 필요함.
->올바른 객체지향적 설계가 아님.


문제해결 방법.
->인터페이스만 의존하게끔 의존관계를 변경하면 된다.
private DiscountPolicy discountPolicy;
이렇게 코드를 남겨두면 됨.->역할만 남겨둠.
근데 실행하면? NPE남 ^^
why? Test코드 실행시 discountPolicy관련 메소드 실행시 할당된 객체가 없어서 예외처리가 됨.


->이 문제를 해결하려면 누군가가 클라이언트인 OrderServiceImpl에 DiscountPolicy의 구현객체를
대신 생성하고 "의존성을 주입"시켜줘야한다.
->그래야 역할만 의존하고 구현은 의존하지 않게됨.


_______________________________________________________________________________________

관심사의 분리


App=공연
Interface=배역

배우(=배우 역할)을 정하는 사람은 배역인가?
아니다. 배역에 맞는 배우를 선정하는 사람은 감독,공연기획자,프로듀서이다.

우리가 방금까지 만든 코드는, 배우가 배역을 고르는 코드였다.
배역에 맞는 배우는 배우가 고르는게 아닌, 공연관련 사람이 뽑아야함

공연 기획자(의존성 주입 담당)를 만들고, 역할과 공연기획자의 책임을 확실히 분리해서 구현.


->AppConfig로 공연기획자 구현
앱의 전체 동작방식을 구성(config)하기 위해 구현 객체를 "생성" 및 "연결" 하는 클래스.

이전 코드에선 다양한 클래스에서 역할과 구현을 같이 의존하는 경우가 많았는데,
이걸 모두 추상화 시키기 위해서 AppConfig를 만든거임. 그러니까, 앞으로 역할만
의존하게끔 만들어주는 코드는 모두 AppConfig에서 구현 및 관리를 할 예정.

->역할과 구현으로 private final한 코드를 없애고, 생성자를 만들어서 생성자의 파라미터로
memberRepository를 받아서, 구현이 되게끔.

AppConfig에서 MemberRepository의 구현체를 인자로 받아서 MemberService에 전달해주니까

MemberService의 구현체인 MemberServiceImpl에서, MemberRepository에 대한 추상(인터페이스)
의존 외에 구현에 대한 의존을 할 필요가 없다. 왜? AppConfig에서 파라미터로 구현체를 받아서
memberService에 넘겨줄거니까!
->추상화에 대해서만 의존 가능해짐.


생성자를 통해서 객체가 들어감.(생성자 주입)->생성자를 통해 의존성을 주입해줌.



이렇게 OrderService도 추상에만 의존하게끔 생성자를 통해 인자를 넘겨받게끔 코드를 수정.
OrderService의 경우 역할을 2개 받으니까, 생성자 인자도 2개 받아서 this로 구현 후
AppConfig에서 실제 구현체를 return해서 넘겨주게끔.
->OrderServiceImpl도 역할에 대해서만 의존받고, 구현에 대해선 생성자를 통해서 넘겨받기때문에
"어떤 구현체를 전달받을지 알지 못함"(그럼에도 불구하고 실행이 가능함)


*꿀팁
ctrl+e=내가 들어갔던 클래스들이 시간순으로 정렬돼서 나옴.
ctrl+d=커서가 움직이지 않은채 줄바꿈을 해줌.


이제 MemberServiceImpl은 MemberRepository의 구현에 대한 의존을 하지 않음.
역할만 의존함.
->MemberServiceImpl은 어떤 구현체가 주입될지 알지 못함.
의존관계는 외부(AppConfig)에 맡기고 내 클래스 코드의 실행(메서드들)에만 집중하게 해줌.



결과적으로,
이제 AppConfig에서 구현에 대한 의존을 만들어서, 이 구현의 역할들이 필요한 클래스들에게
넘겨줌.-> 이제 인터페이스(역할)만 알면 구현에 대한 의존은 AppConfig에서 만들어서 넘겨주기
때문에, 구현에 대해선 모든 클래스들이 알 필요가 없다.->실행의 역할만 수행하면 됨.


순서가
AppConfig가 memoryMemberRepository를 생성해서, MemberServiceImpl에 넘겨준다.
->MemberServiceImpl은 생성과 함께 "구현에 대한 의존성을 주입받음."(by AppConfig)


마찬가지로 AppConfig가 MemberRepository의 구현체와 DiscountPolicy의 구현체를
인자로 받아서 객체를 생성해서, OrderServiceImpl에 넘겨준다.(생성과 함께 구현의 의존성 주입)



이제 Member와 Order가 제대로 실행되는지
MemberApp과 OrderApp 클래스에서 코드를 변경해서 실행 해볼건데,
AppConfig appConfig=new AppConfig();
MemberService memberService= appConfig.memberService();
//MemberService memberService=new MemberServiceImpl();
대략적으로 코드가 이렇게 변함.

역할과 구현에 대해 의존을 둘다 주지 않고, appConfig를 통해 
appConfig에서 정한 구현체에 대해 역할에 의존성을 주입시켜줌.


테스트코드의 수정에 있어선 조금 다른데,

역할에 대해 먼저 정의해놓고
@BeforeEach 어노테이션으로 void beforeEach함수가 항상 먼저 실행되게끔
(Test클래스는 모든 메서드를 무작위로 실행하니까)
만들어서, Appconfig진행해주면 됨.


*개꿀팁
ctrl+e+enter->내가 작성한 이전 클래스로 바로 이동.



->결론: DIP를 지키게 됨!(그로인해 OCP도 지키게됨)
why?
AppConfig 클래스를 통해 배역을 할당해주는 공연기획자를 따로 만들었기때문에.
->배우가 배역을 선택할 필요 없이, 배역은 항상 공연기획자가 정해서 배우에게 넣어줌.
->배우는 그냥 연기만 하면 됨.(주어진 배역에 대해)

AppConfig가 역할이 필요한 모든 클래스들에 대한 구현체 클래스 선택을 정해주는 클래스.
->전체 구성을 책임짐.

나머지 클래스들은 기능의 수행만 생각하면 됨.

역할과 책임을 적절히 분리시켜줌(AppConfig로)




_______________________________________________________________________________________


AppConfig refactoring


현재 AppConfig의 문제점
->중복되는 코드가 좀 있고, 역할에 따른 구현이 잘 안보임.(가시성 문제)


우리는 객체 다이어그램 혹은 클래스 다이어그램처럼
각 역할들의 책임과 관계에 대해서 코드를 통해 한눈에 볼 수 있길 원하는데
현재 만든 AppConfig의 경우 단순히 의존성 주입을 위한 연결자 역할만 제공함.
->이 코드가 실제로 어떻게 동작하는지에 대한 가시성이 부족함.


역할들을 드러나게 코드 수정이 필요해 보임.


*꿀팁 ctrl+alt+m 파라미터 리팩토링할때 편함.
->같은 파라미터 객체 생성시 중복되는걸 intellij가 잡아서, 같이 리팩토링해줌.


->리팩토링 해주는 부분들
그냥 단순히 의존성 주입을 위해 구현체 객체를 new로 생성하는게 아니라,
memberRepository 역할을 메소드로 따로 빼서,
구현체를 타입으로 설정해서, memberRepository와 MemoryMeberRepository의 관계를
알수 있게끔 메소드화 시켜줌.

->메소드 이름을 본 순간 역할이 한눈에 들어옴.
memberRepository(역할)는 MemberMemberRepository타입을 return하게끔 구현할 거야.
이런식으로.


이렇게 되면, 클래스 다이어그램의 관계가 AppConfig에서도 보일수 있게끔 리팩토링 한 결과.
역할이 메소드명과 return type으로 바로 알 수 있음.



->역할을 세우고, 구현이 그 안에 들어가게끔.(간단해 보이는데 실제 구현해보려면 매우 어려울듯)




_______________________________________________________________________________________


새로운 구조와 할인정책 적용

Fix->Rate로 할인정책 번경.
이제 클라이언트 코드 변경이 없이, AppConfig만 변경하면 됨.


AppConfig를 만든 효과?
DIP OCP를 지키는 의존성 주입을 만든건데,
이게 클래스의 사용 영역과 클래스 구성 영역이 나눠지게끔 만들어줌.
->앞으로 구현체의 수정에 있어선 구성영역(AppConfig)의 수정만 해주면 사용은
기능의 구현만 해놨기때문에 자동적으로 구현체가 갈아끼워짐에따라 달라짐!


  public DiscountPolicy discountPolicy(){
        return new RateDiscountPolicy();
    }
return타입을 Fix에서 Rate만 바꿔주면, 끝.


->이제 구현체의 변경은 구성(AppConfig)만 바꿔주면 됨.
사용,역할 영역의 코드는 바꿔줄 필요 없음.


->코드의 수정 없이 기능의 확장이 가능해짐.(구성영역 코드 수정은 불가피)

우리의 코드의 수정 기준은 클라이언트(서비스,사용)코드의 수정에 있다.
이 코드 수정을 하지않기 위해 구성영역을 따로 빼준거라, 구성영역 코드는 수정할수밖에..

->OCP DIP까지 만족!




_______________________________________________________________________________________


전체 흐름 정리

새로운 할인정책 개발(정액->정률)

바꾸려니, 클라이언트(서비스)코드 수정이 불가피함.
why?구현과 역할을 둘다 의존하고 있어서.
->DIP,OCP 법칙 위반.
->주문 서비스 클라이언트가 너무 많은 일을 하고있었음.


관심사 분리.
앱을 공연
배역을 맡은 배우중 한명이, 다른 배우까지 섭외를 했었음(이전코드)
이제 공연기획자를 따로 섭외해서 이사람이 모든 공연 구성에 있어서 총괄하도록 코드를 수정.
->AppConfig

기존의 클라이언트 클래스,객체들은 이제 실행만 잘되게끔 코드를 짜면 됨.(단일 책임이 더 강화됨)


AppConfig refactoring
구성 정보에서도 역할과 구현을 분리시켜줌.
구현할때 어떤 역할을 구현하는건지 따로 return type과 메소드 이름으로 빼줘서
클래스 다이어그램의 역할과 책임과 관계가 더 잘 보일수 있게끔 변경해줌.


새로운 구조와 할인 정책을 적용 했더니,
AppConfig의 할인정책 return type만 변경해주면, 클라이언트 코드의 수정 없이
구현체의 갈아끼우기가 가능해짐.
->이건 앱을 사용영역과(클라이언트,서비스) 구성영역(Configration)으로 분리해서 가능함.




_______________________________________________________________________________________


좋은 객체지향 설계 SOLID

SRP 단일책임원칙

클라이언트 객체는 기존 코드에선 책임이 많았음.
SRP를 위해 관심사를 분리함.
구현 객체의 생성과 연결(의존성 주입)은 AppConfig가.
클라이언트 객체는 기능의 실행만 담당.(SRP!)


DIP
추상화에 의존해야지, 구체화에 의존하면 안됨.
"의존성 주입"-> DIP를 지키기 위한 아주 유용한 방법 중 하나.

역할만 지정하고 구현을 지정 안하면 NPE가 나기때문에,
이 의존성 주입(구현체 지정)도 AppConfig에 다 뺌.(클라이언트 코드에 의존성(구현체) 주입)
(원래 Impl클래스에서 역할과 구현을 다 의존했음)


OCP 수정 닫힘 확장 열림.
다형성을 사용하고 DIP를 지키면, OCP는 자연스레 지켜짐.
->구성영역의 코드를 변경해서 의존성 주입만 변경시키면, 클라이언트 코드의 수정없이
새로운 기능 확장이 가능해진다.

수정에 닫힌 코드들은 클라이언트 코드(=사용 영역)가 기준.






































