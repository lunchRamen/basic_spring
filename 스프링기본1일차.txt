스프링 기본 1일차

스프링의 기능을 그냥 쓰는건 그렇게 어렵지 않음.
다만, 객체지향의 원리를 토대로 코드를 짜고, 이걸 스프링에 어떻게 적용시킬지에 대한
이해를 바탕으로 한 코딩과는 많은 차이가 있음.
->앱을 개발하는 시야가 달라짐(웹 개발에 대한 해상도가 높아짐)

IoC(제어역전)
DI(의존성 주입)
SOLID
SRP
OCP
DIP
등의 객체지향 개발 원리를 이해 한 후 코딩을 하는게 중요.

스프링을 쓸줄 안다고 개발을 잘하는게 아니라, 스프링 프레임워크가 자바로부터 파생되었고
이 자바가 왜 객체지향 언어로써 만들어졌고 객체지향적으로 코딩을 하려면 어떻게 해야 하는지에
대해 강의에서 배우고, 이걸 스프링에 응용해서 스프링을 통해 웹 어플리케이션을 개발 할 예정.

스프링이 없어서 자바로만 객체지향 코드를 짜는것부터 시작해서,
스프링을 통해 편의성을 올리고 코드의 반복성을 줄임으로써 객체지향 코딩에 있어
스프링을 쓰는 이유를 상기시켜줌.

그래서 강의 커리큘럼 자체가
1~3까진 객체지향적 설계(in java)와 이걸 스프링으로 적용시키는 과정(스프링의 핵심 원리)
4~부턴 스프링의 핵심기능들이 왜 만들어졌는지, 왜 필요한지, 실무에서 어떤 방식으로 사용되는지
깊게 이해하는 파트.

강의 목표
단순한 레퍼런스 도큐먼트 설명이 아니라, 왜 스프링이 만들어졌는지에 대한 이유와 핵심원리 설명.
->스프링 기본 기능 학습,본질에 대한 깊은 이해, 객체지향 설계 가능한 개발자로 성장 가능.

이후 중급편에선 컨테이너 확장,AOP동작 원리와 스프링의 기타 기능들을 다룰 예정.
->심화과정으로 보면 됨.


__________________________________________________________________________________________


스프링의 탄생 배경(2000년대 초반)

스프링 탄생 전, Enterprise Java Beans(EJB) 자바의 표준 기술.
->다양한 분야의 개발영업을할때 많이 쓰인 기술.

EJB의 특징
서버의 분산. 이론적부분 탄탄. 엔티티 빈(ORM기술인 JPA) 지원.

다만, 매우 비쌌음. 그리고 진짜 어렵고 복잡함.
->그래서 spring 오픈소스를 만들게 됨.(EJB 컨테이너 대체)

rod johnson이 spring
개빈킹이 hibernate를 만듬.

JPA는 표준 인터페이스. JPA의 구현체들로 hibernate가 있음.(대표적)



스프링 역사.
로드존슨이 2002년 EJB를 지적하며 이를 해결 가능한 프로젝트 코드를 작성해서 책을 출간.
히트를 친 후, 유겐휠러와 얀카로프가 위 책을 오픈소스화 시켜서 만든게 spring.

그렇다면, 왜 이 코드를 만들어서 오픈소스화 시켜서 spring을 만들었을까?
->말보다 실제 코드로 작성해보며 스프링화 된 코드를 짜야되는 이유를 이해하게 됨.

2003~2013까지 스프링 프레임워크가 1.0~4.0 업데이트.
2014:스프링 부트 1.0 출시.
왜 스프링을 냅두고 스프링부트가 10년이 지난 후에 출시?
->스프링이 설정이 너무 힘들고, 톰캣(내장서버)에 배포해보는 세팅도 번거로움.
2017:스프링 5.0 스프링부트 2.0->리엑티브(NodeJs처럼 프로그래밍 가능)



스프링이란?
스프링 생태계
스프링이란, 여러가지 기술의 모음이라고 보면 됨.
스프링 프레임워크,스프링 부트, 스프링 데이터, 스프링 세션, 스프링 시큐리티, 스프링 rest docs
스프링 배치, 스프링 클라이드 등등

스프링 데이터:데이터를 다루기 편하게끔.
스프링 세션:세션 기능을 다루기 편하게끔.
스프링 시큐리티: 보안관련.
스프링 Rest Docs:API 서류 작성 편하게끔.
스프링 batch:배치(데이터들 중 일부분씩 퍼 올려서 업데이트하고 다시 넣는 기술) 편하게끔
스프링 클라우드:클라우드 기술 특화.

제일 중요한것: 스프링 프레임 워크.
스프링 프레임 워크 구동 편하게끔 해주는 것: 스프링 부트

스프링 프레임워크
핵심 기술: DI컨테이너, AOP,이벤트
웹 기술: MVC,WebFlux
데이터 접근 기술:트랜잭션,JDBC,ORM,XML
기술 통합:캐시,이메일,원격접근,스케줄링
테스트:테스트 지원
언어:코틀린 그루비


우린 핵심기술에 초점을 맞춰 진행할 예정.
+스프링 부트를 함께

스프링 부트
스프링을 편리하게 사용 할 수 있도록. 기본적으로 사용함 요즘은.

단독 실행 가능한 스프링 앱(톰캣같은 웹서버를 내장) 쉽게 생성.

손쉬운 빌드 구성을 위한 starter 종속성 제공
->스프링이 워낙 크다보니 라이브러리가 크고 서로 연관성이 있는데, starter를 달아놓으면
해당 API를 import했을때 거기에 연관성이 있는 API들까지 한꺼번에 묶어 가져옴.

스프링과 외부 라이브러리 자동구성.
->스프링 프레임워크의 버전과 잘 호환되는 라이브러리 버전을 알아서 가져와줌.

메트릭,상태확인,외부거성같은 프로덕션 준비기능 제공.
->프로그램 모니터링을 간편하게 해줌.

관례에 의한 간결한 설정.
->디폴트 설정을 알아서 다해주고 필요한 부분만 조금씩 고치면 되게끔.



스프링 부트는 스프링 프레임워크를 편리하게 사용할 수 있는 기능 제공.
->스프링 부트 단독 사용은 불가능함.



스프링
스프링 DI 컨테이너 기술.(스프링 빈 관리)
스프링 프레임워크
스프링에 관련된 스프링 생태계.



스프링을 만든 이유?
*****스프링의 핵심 개념(컨셉)*****
좋은 객체 지향 앱을 개발 할 수 있게끔 도와주는 프레임워크.
당시에 로드존슨이 J2EE를 만든 이유.
그 이전 EJB에 종속돼서 객체지향적 특성을 잃어버린 코드들을 되살려줌.




__________________________________________________________________________________________



좋은 객체지향 프로그래밍

추상화,캡슐화,상속,다형성

객체지향 프로그래밍:컴퓨터 프로그램을 독립된 단위(객체)로 파악해서 
메시지를 주고받고 데이터 처리.(협력) 유연하고 변경이 유용.

유연하고 변경이 용이
->컴퓨터 부품을 갈아끼우듯이 컴포넌트를 쉽고 유연하게 변경하면서 개발하는것
->객체지향의 핵심은 "다형성"이다.

다형성의 실생활 비유(완벽히 맞진 않지만 이해하긴 쉬움)
->세상을 역할과 구현으로 구분.

운전자-자동차.

자동차 역할:K3,아반떼,모델3,기블리 등등(구현체)

운전자는 자동차가 바뀌어도 영향을 받지 않고 운전을 잘 할 수있다->이 부분이 중요.
이걸 코드에서 똑같이 적용 가능해야함. 구현체를 바꾼다고해서 코드의 수정이 필요하지 않아야 함.
->자동차 인터페이스를 따라서 자동차 구현체들이 구현되었기 때문에 운전자는 자동차의 인터페이스
만 알고있음에도, 자동차 인터페이스를 상속받은 모든 자동차 구현체들에 대한 운전이 가능한 것.

why?운전자를 위해서.(운전자는 자동차 인터페이스만 알고 구현원리를 몰라도 작동을 할 수 있음)
구현체가 바뀜에 따라 엔진의 성능, 외관의 크기, 인테리어의 변경등의 구현상의 차이는 있지만
인터페이스(시동,악셀,백미러,사이드미러,계기판)등은 모두 동일하기에.
->자동차 세상의 무한한 확장이 가능함.

"클라이언트(운전자)에 영향을 주지 않고, 새로운 기능을 제공 가능."
왜? 역할과 구현으로 세상을 나누어서 보았기때문에.
중요한것은, 자동차의 역할을 여러개 구현하는게 아니라, 새로운 자동차가 구현되어도
운전자에게 새로운 요구사항이 없다는 것.


공연무대
로미오-줄리엣
로미오 역할
줄리엣 역할.

로미오와 줄리엣은 누가 하든 상관이 없음.그리고 그 구현체(배우)가 바뀐다고해서
달라질게 없음. 그렇다면 로미오=클라이언트 줄리엣=서버라고 봤을때,

줄리엣의 구현이 바뀐다고 로미오의 역할이 바뀌지않음. 다른 구현체로 대체 가능.
->유연하고 변경이 용이.

나머지:키보드,마우스,표준 인터페이스의 구현체들.



"역할과 구현의 분리"
->세상이 단순해지고, 유연해지며 변경도 편리해진다.

클라이언트는 대상의 "역할"만 알면 된다.=인터페이스만 알면 된다.
		   구현이(내부구조) 바뀌어도 영향을 받지 않는다.=인터페이스만 알면 된다.
		   구현체가 바뀌어도 영향을 받지 않는다.=인터페이스만 알면 된다.


전기차가 나와도, 롤스로이스가 나와도 나는 자동차 인터페이스를 아니까, 딱히 나를 수정할 필요X.

이걸 프로그래밍 언어에서 차용.
->역할:인터페이스
   구현:인터페이스를 구현한 클래스(구현체)

객체를 설계시 "역할과 구현"을 "명확히 분리".
객체를 설계시 역할을 먼저 부여하고, 그 역할을 수행하는 구현체 만들기.


객체의 협력이라는 관계부터 생각.
클라이언트:요청	서버:응답
수많은 "객체"클라이언트와 "객체"서버가 협력하며 프로그램이 상호소통함.

클라이언트는 클라이언트이면서 동시에 서버가 될 수 있다.


자바의 다형성 구현.
->오버라이딩.(기본 문법)

ex) MemberService에서 MemberRepository인터페이스 객체를 생성하고, 거기에 정의된
save메서드 호출시, 경우에 따라 MemberRepository인터페이스를 구현한 구현체들 중 하나의
재정의 된 save메서드가 호출된다.

다형성으로 인터페이스를 구현한 객체를 "실행 시점(run time)"에서 유연하게 변경 가능.
->객체지향의 다형성의 최종 목적.


다시 정의.
MemberService(클라이언트)에서 MemberRepository의 save함수를 호출.
->MemberService는 MemberRepository를 의존하고 있음.
"의존하다"-> MemberService 클래스에서 MemberRepository를 알고있다.
이후, 때에 따라 MemberRepository를 구현한 Memory-와 Jdbc-를 호출하면
그에 해당되는 save함수가 호출.

ex) public class MemberService{
	private MemberRepository memberRepository=new MemoryMemberRepository();
	or
	private MemberRepository memberRepository=new JdbcMemberRepository();
}
->해당 인터페이스를 오버라이딩한 구현체들이 블록처럼 끼워짐.
(부모클래스와 자식클래스의 상속관계로 봐도 무방)



다형성의 본질
->인터페이스를 구현한 객체 인스턴스(실물)을 실행시점에 유연하게 변경 가능.
->"협력"이라는 객체사이의 관계에서 시작.
->"클라이언트를 변경하지 않고",서버의 구현 기능을 유연하게 변경.




정리
실생활에서 역할과 구현이라는 컨셉을 프로그래밍으로 가져온것=객체지향 프로그래밍.
유연하고 변경 용이.
확장 가능한 설계.(인터페이스를 상속받아 구현 및 확장)
클라이언트를 변경하지 않는게 가장 중요.
->이러려면 인터페이스를 안정적으로 설계해야함.



한계
역할(인터페이스)이 변하면, 클라이언트와 서버 모두에 큰 변경 발생.
ex)자동차가 비행기로? 대본이 변경? -> 인터페이스를 잘 설계하는게 제일 중요.(변화가 없게끔)




스프링과 객체지향
객체지향의 꽃=다형성.
->스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
ex)IoC(제어 역전) DI(의존관계 주입)
->다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원.
->스프링을 사용하면 레고블록 조립하듯이 "구현"을 편리하게 변경 할 수 있다.

스프링 DI컨테이너,DI,다형성이 합쳐져서 구현을 편리하게 변경 가능하게끔 만들어줌.


다형성+SOLID도 알아야함.(좋은 객체지향 설계의 5가지 원칙)->spring


__________________________________________________________________________________________


SOLID
클린코드를 위한 좋은 객체지향 설계의 5가지 원칙.

SRP
OCP
LSP
ISP
DIP



SRP(단일 책임 원칙)
하나의 클래스는 하나의 책임만 가져야한다.
하나의 책임이라는게 좀 모호함.
(책임의 크기, 문맥과 상황을 따져봐야함)
기준:"변경". 변경이 있을때 파급효과가 적다면->SRP를 따른 것.
ex)객체의 생성과 사용 분리.

->계층 분리를 잘하는것=SRP를 잘 따른것.
->너무 잘개도, 너무 크게도 쪼개지 않는게 중요함.



OCP(개방 폐쇄 원칙) ***제일 중요***
확장에는 열려있으나 변경에는 닫혀있어야함.
코드의 변경 없이 기능의 확장?
->다형성을 활용해서 구현 가능.
인터페이스를 구현한 구현체에 새로운 기능을 추가해서 구현하면? 
코드의 변경 없이 새로운 기능의 확장이 가능하다.

역할과 구현의 분리에서, 구현을 통한 역할의 의존관계만 수정해주면 코드의 수정없이
기능의 확장을 구현한 케이스.

ex) public class MemberService{
	private MemberRepository memberRepository=new MemoryMemberRepository();
	or
	private MemberRepository memberRepository=new JdbcMemberRepository();
}

근데, MemberService가 클라이언트 역할인데 구현체에 따라 코드의 수정이 불가피함.
-> OCP를 지킬수 없다.
어떻게 해결? 객체간의 연관관계를 맺어주는 "별도의 조립,설정자"가 필요하다.
->스프링 컨테이너가 해결해줌.




LSP
객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위타입의 인스턴스로 바꿀 수 있어야 한다.
->다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야함. 인터페이스를 구현한 구현체를
믿고 사용하기 위한 원칙.
ex)엑셀은 밟으면 앞으로 가야함. ->밟으면 뒤로가게끔 구현하면 절대 안됨. 신뢰를 깨뜨림.
근데 구현 자체는 가능함(컴파일 성공). 다만 약속이니까 그렇게 구현하지 않는것.




ISP 인터페이스 분리 원칙
특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.
ex)자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스.
   사용자  클라이언트 -> 운전자 클라이언트, 정비사 클라이언트.

인터페이스가 명확해지고, 대체가능성이 높아짐.




DIP 의존관계 역전 원칙 **중요**(OCP만큼 중요)
"추상화에 의존"해야지, 구체화에 의존하면 안된다.
->의존성 주입(DI)은 이 원칙을 따름.

구현 클래스에 의존하지말고, 인터페이스에 의존하라는 뜻.
=역할에 의존하게 설계해야한다.(구현이 아니라)

->운전자(클라이언트)는 역할(자동차)에 대해서만 알면 되지, 구현(k3)에 대해 알 필요가 없다.

"역할과 구현을 철저하게 분리해야한다."
->이러려면, 역할에 집중해서 코드를 설계해야한다.
구현에 의존하게 되면 변경에 아주 어려워진다.

의존한다?==안다.
의존성 주입? 해당 인터페이스(클래스)를 알게끔 해주는 것.

ex) public class MemberService{
	private MemberRepository memberRepository=new MemoryMemberRepository();
	or
	private MemberRepository memberRepository=new JdbcMemberRepository();
}

이 코드에서 MemberService는 MemberRepository,Memory,Jdbc에 대해 의존하고 있다.
의존관계가 여러개니까, OCP를 못지키고 클라이언트 코드의 수정이 불가피 한 것.
=구현 클래스를 직접 선택해야함.
->DIP위반.

얼핏 보면 잘 추상화된 인터페이스인 MemberRepository를 의존하고 있지만, 그 인터페이스의
구현체들도 의존하고 있기에, 구현클래스의 의존성을 없애줘야 DIP를 유지 할 수 있다.





정리

객체지향=다형성
다형성만으로는, 레고블록 맞추듯이 개발 할 수 없다.
	         구현 객체 변경시 클라이언트 코드도 함께 변경.
->OCP,DIP를 위반할 수밖에 없다.
->"다른 보조적인 기능들"이 필요하다.




__________________________________________________________________________________________



객체지향 설계와 스프링


스프링이 다형성+OCP+DIP가 가능하게끔 지원해줌.

->DI와 DI컨테이너를 제공함으로써. 클라이언트 코드 변경 없이 기능 확장.
->블록 갈아끼우듯이 개발 가능!

스프링이 없을땐, OCP DIP를 지키려면 부가적인 코드가 많이 필요.
->결과론적으론 OCP DIP를 지켜주는 스프링 프레임워크 개발이 필수적이게 된다.



정리
설계에 역할과 구현을 분리.
->배역만 만들어놓고, 배우는 언제든 "유연"하게 "변경"가능하게끔 설계하는것
=좋은 객체지향 설계.
이러려면 모든 설계에 인터페이스를 부여해서 역할과 구현을 분리하면 됨!

인터페이스를 먼저 만들어 놓으면, 하위 구현 기술들을 구체적으로 정하지 않아도
인터페이스를 따라 간단히 개발해놓고, 구현기술이 정해지면 해당 인터페이스를 구현하는
다른 구현체로 구현하면 된다.


실무적 고민
->모든 설계에 인터페이스를 부여하면, 추상화라는 비용이 발생.
추상화가 되어버리면, 클래스를 두번 열어봐야됨. 인터페이스->구현체.
장점(유연하게 변경)이 단점(두번 열어보는것)을 능가할때, 인터페이스로 구현.
ex)기능을 확장할 가능성이 없는 클래스의 경우 구현클래스 자체로 직접 사용.
향후 꼭 필요할때 인터페이스로와 구현체로 리팩토링 하는것도 방법.


이런 기준점들을 잡는건 본다고 되는게 아니라, 실무적 경험이 쌓이면서 감으로 터득하게 됨.






























