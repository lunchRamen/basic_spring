스프링 기본 4일차


___________________________________________________________________________________________________

IoC DI 컨테이너


IoC:Inversion of Control =제어의 역전.
보통 개발자가 직접 제어하는 스타일로 개발을 하는데,
프레임워크가 내 코드를 대신 제어해서 호출하는 경우.




기존 프로그램은 클라이언트 구현 객체가 프로그램 제어흐름을 스스로 조종.
AppConfig가 등장 이후, 프로그램 제어흐름을 가져감.
->개발자 입장에서 자연스러운 흐름은 아님.

AppConfig가 서비스,멤버의 구현 및 서비스와 멤버에 필요한 인터페이스와 구현체 또한
생성자를 통해 입력받아 의존성을 주입해줌.

->프로그램 제어 흐름을 외부(AppConfig)에서 관리하는게 IoC

***프레임워크 vs 라이브러리***
제어권을 대신 실행한다=프레임워크
내가 작성한 코드를 통해 제어해서 실행한다=라이브러리



의존관계 주입(DI)
OrderServiceImpl은 DiscountPolicy(역할)에만 의존하게끔 수정함.
이제 실제 구현객체가 뭐가 올지 모름. 그냥 해당 역할을 수행하게끔 실행함.


의존관계는 정적인 클래스 의존관계와
	  동적인 클래스 의존관계를 분리해서 생각해야함.

ex) MemberRepository와 DiscountPolicy는 정적으로 의존관계가 파악 가능.
(실행하지 않아도 파악 가능)

근데 OrderServiceImpl의 생성자에서 의존성 주입을 시켜줄때
어떤 구현체가 들어와서 실행이 될지 모름. -> 동적 클래스 의존관계.


*런타임에 외부에서 실제 구현체를 생성하고 클라이언트에 전달해서 의존관계가
연결되는것을 "의존관계 주입"이라 한다.*


의존관계 주입을 사용하면, 클라이언트 코드 변경 없이 호출 객체를 변경 할 수 있다.
		       정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 변경 가능.
		       

IoC컨테이너 DI컨테이너

AppConfig처럼 객체 생성 관리,의존관계 주입을 해주는 역할을
IoC컨테이너 혹은 DI컨테이너라고 부름.
(제어관계 역전을 시켜주거나 의존성 주입을 시켜주는 컨테이너)

AppConfig에선 제어흐름역전과 의존성 주입 둘 다 일어나는데
이것 조차 나눠서 하는 경우가 있는듯? 그래서 DI컨테이너를 따로 분리한듯 싶음.

스프링이 DI컨테이너 역할을 해줌!




___________________________________________________________________________________________________

자바코드 -> 스프링으로 전환


AppConfig 클래스 앞엔 @Configuration 어노테이션(설정 정보)


의존성 주입 메서드들 앞에는 @Bean 어노테이션.
->스프링 빈으로 등록하기 위해.


->빈으로 붙인 애들이 다 스프링 컨테이너에 등록된다.


main에서 빈으로 등록된 애들을 스프링에서 쓰려면

ApplicationContext applicationContext=new AnnotationConfigApplicationContext(AppConfig.class);
이렇게 AppConfig하듯이 위 코드를 작성해주면 됨.


ApplicationContext applicationContext=
new AnnotationConfigApplicationContext(AppConfig.class);
MemberService memberService = 
applicationContext.getBean("memberService", MemberService.class);

이렇게 스프링 빈을 꺼내 써와서 멤버 서비스에 대한 의존성 주입 메서드를 쓸 수 있따.



스프링 컨테이너
ApplicationContext를 "스프링 컨테이너"라고 한다.

AppConfig를 사용해서 객체 생성 후 의존성 주입을 해줬는데, 이젠 스프링 컨테이너를 통해서
객체 생성 후 의존성 주입해주면 됨.

스프링 컨테이너는 ApplicationContext 객체가 생성되면,
@Configuration이 붙은 class의 @Bean이라 적힌 모든 메서드들을 가져옴.

스프링 컨테이너에 등록된 객체를 스프링 빈이라고 한다.
메서드명=빈 이름.
이름을 바꾸고 싶다?
@Bean(change)
이렇게 바꾸면 메서드 이름과 다른 빈 이름을 사용.

이전에는 AppConfig를 통해서 조회했지만, 이젠 스프링 컨테이너를 통해서 조회함.


원래 개발자가 제어흐름을 AppConfig에 맡기긴 했지만, 내가 만든 코드였는데
이젠 스프링 컨테이너에 제어흐름을 아예 맡겨버리고 알아서 동작하게끔
->이래서 스프링이 프레임워크다.(제어흐름 역전을 가져옴)



AppConfig말고 스프링 컨테이너를 사용 했을때 장점?
(오히려 코드가 더 늘어났는데..)

앞으로의 강의.


























































